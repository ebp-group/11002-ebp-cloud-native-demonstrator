<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cloud-Native Geospatial Demonstrator</title>
    <script type="module" crossorigin src="/11002-ebp-cloud-native-demonstrator/assets/geoparquet-tvadRmBH.js"></script>
    <link rel="modulepreload" crossorigin href="/11002-ebp-cloud-native-demonstrator/assets/index-AK0TvtvL.js">
    <link rel="modulepreload" crossorigin href="/11002-ebp-cloud-native-demonstrator/assets/data-B7ka6WSd.js">
    <link rel="stylesheet" crossorigin href="/11002-ebp-cloud-native-demonstrator/assets/index-BCd0ybmK.css">
  </head>
  <body>
    <div class="container-fluid h-100">
      <div class="row h-100">
        <div class="col-6 p-0">
          <div id="map" class="h-100"></div>
        </div>
        <div class="col-6 p-4 h-100 d-flex flex-column">
          <a href="../../">&leftarrow;Back to start</a>
          <h1 class="display-1">(Geo)Parquet</h1>
          <div class="alert alert-info">
            <select id="rendercountry" class="form-select">
              <option disabled selected><b>Render BBOX for</b></option>
              <option value="508f8d1f-2491-437c-b857-f44ccc0446ad">Switzerland</option>
              <option value="d95d3f8a-a2f4-4436-b0e4-a3a86d15008e">Germany</option>
            </select>
          </div>
          <div class="overflow-auto">
            <h2 class="display-6">General</h2>
            <ul>
              <li>
                Datasource:
                <a href="https://docs.overturemaps.org/guides/divisions/#data-access-and-retrieval" target="_blank"
                  >Ouverture Maps Foundation (Dataset <i>Divisions, 2025-11-19.0</i></a
                >
              </li>
              <li>
                Additional library needed:
                <a href="https://www.npmjs.com/package/@duckdb/duckdb-wasm" target="_blank">duckdb/duckdb-wasm</a>
              </li>
              <li>Datafile is roughly 700MB, see network tab to see the rangerequests in action.</li>
            </ul>
            <hr />
            <h2 class="display-6">Things to note</h2>
            <div class="alert alert-warning">
              <b>Important:</b>Versions <code>>=1.29.1-dev260.0</code>of <code>duckdb/duckdb-wasm</code> seem to have introduced a bug where
              range requests are not used. Hence, this demonstrator uses a pinned version (<code>1.29.1-dev260.0</code>).
            </div>
            <p>
              By selecting a country from the dropdown, its bounding box is fetched from the Parquet file and rendered on the map &mdash;
              once again, this is all powered by range requests in that only those bytes are fetched to represent the row. Because the query
              is very selective (only one row) and we narrow it down by ID, DuckDB can use
              <a href="https://duckdb.org/docs/stable/data/parquet/tips#selecting-a-row_group_size" target="_blank">predicate pushdown</a>
              to efficiently retrieve the byte range necessary for the full row. The query is a simple SQL query that reads the parquet file
              directly via http:
            </p>
            <pre><code class="language-sql">SELECT id, country, names, bbox, region, subtype, class, type
  FROM read_parquet('${PARQUET_LOCATION}')
  WHERE id = ?</code></pre>
            <p>
              We currently do not use the <i>Geo</i>Parquet capabilities, as fetching the geometry fields triggers almost a full file
              download, possibly related to how the file was generated and/or the binary geometries are stored. It should merely showcase
              how DuckDB can be leveraged to query parquet files; also not that DuckDB WASM is not a fully DuckDB compliant version as of
              right now (see <a href="https://duckdb.org/docs/stable/clients/wasm/overview#limitations" target="_blank">limitiations</a>).
            </p>

            <li>Geo integration fetches whole file, so just bboxes</li>
            <li>Range requests are finicky, potentially optimizable via files</li>
            <li>Experimental</li>
            <li>Code is ugly; complicated to use with WASM Table etc</li>
            <li>
              Locally -> use http-server with npx http-server -o ./ -g --cors=Accept-Ranges,Content-Length,ETag,Last-Modified,Content-Range
              <code>
                <IfModule mod_headers.c>
                  Header set Access-Control-Allow-Origin "*" Header set Access-Control-Allow-Headers "Origin, X-Requested-With,
                  Content-Type, Accept, Range, Accept-Ranges, Content-Length, ETag, Last-Modified, Content-Range" Header set
                  Access-Control-Expose-Headers "Content-Range, Content-Length, ETag, Last-Modified" Header set Access-Control-Allow-Methods
                  "GET, OPTIONS, HEAD" # Cache-Control for static content (adjust as needed)
                  <!--<FilesMatch "\.(tif|parquet|pmtiles|fgb)$">
                                Header set Cache-Control "public, max-age=3600"
                                </FilesMatch>-->

                  # Keep-Alive settings (timeout & max) Header set Connection "keep-alive" Header set Keep-Alive "timeout=5, max=100"
                </IfModule>
              </code>
            </li>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
